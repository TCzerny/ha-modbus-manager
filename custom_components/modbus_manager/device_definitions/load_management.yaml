# Load Management System
# Coordinates load distribution between all configured devices

helpers:
  templates:
    # Available surplus power
    - name: "available_surplus_power"
      unique_id: "available_surplus_power"
      value: >
        {% try %}
          {% set data = namespace(pv=0, home=0, battery=0, ev=0) %}
          {% for entity_id in states.sensor | selectattr('entity_id', 'match', '.*total_active_power$') %}
            {% if not is_state(entity_id.entity_id, 'unavailable') and not is_state(entity_id.entity_id, 'unknown') %}
              {% set data.pv = data.pv + entity_id.state | float(0) %}
            {% endif %}
          {% endfor %}
          {% for entity_id in states.sensor | selectattr('entity_id', 'match', '.*home_consumption$') %}
            {% set data.home = data.home + entity_id.state | float(0) %}
          {% endfor %}
          {% for entity_id in states.sensor | selectattr('entity_id', 'match', '.*battery_power$') %}
            {% set data.battery = data.battery + entity_id.state | float(0) %}
          {% endfor %}
          {% for entity_id in states.sensor | selectattr('entity_id', 'match', '.*charging_power$') %}
            {% set data.ev = data.ev + entity_id.state | float(0) %}
          {% endfor %}
          {{ (data.pv - data.home - data.battery - data.ev) | round(0) }}
        {% except %}
          {{ 0 }}  {# Fallback on errors #}
        {% endtry %}
      attributes:
        pv_power: "{{ data.pv }}"
        home_consumption: "{{ data.home }}"
        battery_power: "{{ data.battery }}"
        ev_charging: "{{ data.ev }}"
        last_update: "{{ now() }}"
      unit_of_measurement: "W"
      device_class: "power"

    # Dynamische Lastpriorisierung
    - name: "load_priority_list"
      unique_id: "load_priority_list"
      value: >
        {% set devices = [] %}
        {% set valid_priorities = [] %}
        {% for entity_id in states.number | selectattr('entity_id', 'match', '.*load_priority$') %}
          {% if not is_state(entity_id.entity_id, 'unavailable') %}
            {% set device = namespace() %}
            {% set base_id = entity_id.entity_id.split('_load_priority')[0] %}
            {% if states(base_id ~ '_power') not in ['unavailable', 'unknown'] %}
              {% set device.entity_id = base_id %}
              {% set device.priority = entity_id.state | int(99) %}
              {% set device.min_power = states(base_id ~ '_min_power') | float(0) %}
              {% set device.max_power = states(base_id ~ '_max_power') | float(11000) %}
              {% set device.current_power = states(base_id ~ '_power') | float(0) %}
              {% set device.available = true %}
              {% set devices = devices + [device] %}
              {% set valid_priorities = valid_priorities + [device.priority] %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ devices | sort(attribute='priority') | list }}
      attributes:
        valid_device_count: "{{ devices | length }}"
        priority_conflicts: "{{ valid_priorities | length != valid_priorities | unique | length }}"

    # Erweiterte Lastüberwachung
    - name: "load_management_status"
      unique_id: "load_management_status"
      value: >
        {% set data = namespace(
          total_load=0,
          peak_load=0,
          devices=[],
          load_distribution={},
          optimization_potential=0
        ) %}
        
        {# Sammle Lastdaten aller Geräte #}
        {% for entity_id in states.sensor | selectattr('entity_id', 'match', '.*power$') %}
          {% set device_name = entity_id.entity_id.split('.')[1].split('_power')[0] %}
          {% set power = states(entity_id.entity_id)|float(0) %}
          {% set priority = states(device_name ~ '_priority')|int(99) %}
          {% set min_power = states(device_name ~ '_min_power')|float(0) %}
          {% set max_power = states(device_name ~ '_max_power')|float(0) %}
          
          {% set device_data = {
            'name': device_name,
            'current_power': power,
            'priority': priority,
            'min_power': min_power,
            'max_power': max_power,
            'optimization_potential': max_power - power if power < max_power else 0
          } %}
          
          {% set data.devices = data.devices + [device_data] %}
          {% set data.total_load = data.total_load + power %}
          {% set data.peak_load = data.peak_load if data.peak_load > power else power %}
          {% set data.optimization_potential = data.optimization_potential + device_data.optimization_potential %}
        {% endfor %}
        
        {# Berechne Lastverteilung #}
        {% for device in data.devices %}
          {% set data.load_distribution = data.load_distribution.update({
            device.name: (device.current_power / data.total_load * 100)|round(1)
          }) %}
        {% endfor %}
        
        {
          "current_status": {
            "total_load": data.total_load,
            "peak_load": data.peak_load,
            "device_count": data.devices|length,
            "load_distribution": data.load_distribution
          },
          "optimization": {
            "potential": data.optimization_potential,
            "recommendations": data.devices|sort(attribute='optimization_potential', reverse=true)|map(attribute='name')|list
          },
          "devices": data.devices|sort(attribute='priority'),
          "last_update": now()
        }

automations:
  # Dynamische Lastverteilung
  - name: "dynamic_load_distribution"
    unique_id: "dynamic_load_distribution"
    trigger:
      - platform: state
        entity_id: sensor.available_surplus_power
      - platform: state
        entity_id: sensor.load_priority_list
    condition:
      - condition: template
        value_template: "{{ trigger.to_state.state | float(0) != trigger.from_state.state | float(0) }}"
    action:
      - service: script.distribute_power
        data:
          available_power: "{{ states('sensor.available_surplus_power') | float(0) }}"
          priority_list: "{{ states('sensor.load_priority_list') }}"

  # Lastspitzen-Vermeidung
  - name: "peak_load_prevention"
    unique_id: "peak_load_prevention"
    trigger:
      platform: numeric_state
      entity_id: sensor.total_grid_power
      above: 11000
    action:
      - service: script.reduce_managed_loads
        data:
          excess_power: "{{ states('sensor.total_grid_power') | float(0) - 11000 }}"

  # Lastoptimierung
  - name: "load_optimization"
    unique_id: "load_optimization"
    trigger:
      platform: state
      entity_id: sensor.load_management_status
    condition:
      condition: template
      value_template: >
        {% set status = states('sensor.load_management_status')|from_json %}
        {{ status.optimization.potential > 1000 }}  # Mehr als 1kW Optimierungspotential
    action:
      - service: script.optimize_load_distribution
        data:
          optimization_data: "{{ states('sensor.load_management_status') }}"

scripts:
  distribute_power:
    sequence:
      - service: script.calculate_power_distribution
        data:
          available_power: "{{ available_power }}"
          priority_list: "{{ priority_list }}"
      - parallel:
          - repeat:
              count: "{{ priority_list | length }}"
              sequence:
                - service: number.set_value
                  target:
                    entity_id: "{{ priority_list[repeat.index-1].entity_id }}_power_setpoint"
                  data:
                    value: "{{ priority_list[repeat.index-1].calculated_power }}"

  reduce_managed_loads:
    sequence:
      - service: script.calculate_load_reduction
        data:
          excess_power: "{{ excess_power }}"
      - parallel:
          - repeat:
              count: "{{ priority_list | length }}"
              sequence:
                - service: number.set_value
                  target:
                    entity_id: "{{ priority_list[repeat.index-1].entity_id }}_power_setpoint"
                  data:
                    value: "{{ priority_list[repeat.index-1].reduced_power }}"