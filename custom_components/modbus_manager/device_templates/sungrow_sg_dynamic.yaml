# Sungrow SG Dynamic Template for Modbus Manager
# BASED ON: TI_20230117_Communication.Protocol.of.Residential.and.Commerical.PV.Grid-connected.Inverter_V1.1.53_EN.pdf

name: "Sungrow SG Series Inverter"
description: "Dynamic template for Sungrow SG series residential and commercial PV grid-connected inverters. Based on Communication Protocol V1.1.53. (RS, RT, HX, KTL, KTL-MT, HV/BF, CX Series)"
manufacturer: "Sungrow"
model: "SG Series Dynamic"
version: 1.3.1
default_prefix: "SG"
default_slave_id: 1
type: "PV_Inverter"
firmware_version: "SAPPHIRE-H_xxxx"

# Dynamic configuration support
dynamic_config:

  # Model-specific configuration (shows model dropdown instead of individual fields)
  valid_models:
    # RS Series (Single Phase)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - from datasheet (Datasheet_Sungrow_1ph_SG3.0-6.0RS_V11)
    "SG3.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0x2603", max_ac_output_power: 3000, max_current: 14}  # Datasheet: 13.7A, rounded to 14A
    "SG3.6RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0x2604", max_ac_output_power: 3680, max_current: 16}  # Datasheet: 16.0A
    "SG4.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0x2605", max_ac_output_power: 4000, max_current: 18}  # Datasheet: 18.2A, rounded to 18A
    "SG5.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0x2606", max_ac_output_power: 5000, max_current: 23}  # Datasheet: 22.8A, rounded to 23A
    "SG6.0RS": {phases: 1, mppt_count: 2, string_count: 1, type_code: "0x2607", max_ac_output_power: 6000, max_current: 27}  # Datasheet: 27.3A, rounded to 27A
    "SG8.0RS": {phases: 1, mppt_count: 3, string_count: 1, type_code: "0x2608", max_ac_output_power: 8000, max_current: 36}  # TODO: Verify from datasheet
    "SG10RS": {phases: 1, mppt_count: 3, string_count: 1, type_code: "0x2609", max_ac_output_power: 10000, max_current: 45}  # TODO: Verify from datasheet

    # RT Series (Three Phase)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - from datasheet (DS_20231113_SG5.0_6.0_7.0_8.0_10_12RT-P2_V2_EN)
    "SG3.0RT": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0x243D", max_ac_output_power: 3000, max_current: 5}  # TODO: Verify from datasheet
    "SG4.0RT": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0x243E", max_ac_output_power: 4000, max_current: 6}  # TODO: Verify from datasheet
    "SG5.0RT": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0x2430", max_ac_output_power: 5000, max_current: 8}  # Datasheet: 8.3A, rounded to 8A
    "SG6.0RT": {phases: 3, mppt_count: 2, string_count: 1, type_code: "0x2431", max_ac_output_power: 6000, max_current: 10}  # Datasheet: 10.0A
    "SG7.0RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x243C", max_ac_output_power: 7000, max_current: 12}  # Datasheet: 11.7A, rounded to 12A
    "SG8.0RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x2432", max_ac_output_power: 8000, max_current: 13}  # Datasheet: 13.3A, rounded to 13A
    "SG10RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x2433", max_ac_output_power: 10000, max_current: 17}  # Datasheet: 16.7A, rounded to 17A
    "SG12RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x2434", max_ac_output_power: 12000, max_current: 20}  # Datasheet: 20.0A
    "SG15RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x2435", max_ac_output_power: 15000, max_current: 25}  # Datasheet: 25A
    "SG20RT": {phases: 3, mppt_count: 2, string_count: 2, type_code: "0x2437", max_ac_output_power: 20000, max_current: 32}  # Datasheet: 31.9A, rounded to 32A

    # KTL Series (Commercial)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - TODO: Verify from datasheet (calculated from max_ac_output_power / (phases * 220V))
    "SG30KTL": {phases: 3, mppt_count: 2, string_count: 4, type_code: "0x27", max_ac_output_power: 30000, max_current: 45}  # TODO: Verify from datasheet
    "SG36KTL": {phases: 3, mppt_count: 2, string_count: 5, type_code: "0x2D", max_ac_output_power: 36000, max_current: 55}  # TODO: Verify from datasheet
    "SG40KTL": {phases: 3, mppt_count: 2, string_count: 4, type_code: "0x2F", max_ac_output_power: 40000, max_current: 61}  # TODO: Verify from datasheet
    "SG60KTL": {phases: 3, mppt_count: 1, string_count: 14, type_code: "0x010F", max_ac_output_power: 60000, max_current: 91}  # TODO: Verify from datasheet
    "SG80KTL": {phases: 3, mppt_count: 1, string_count: 18, type_code: "0x0138", max_ac_output_power: 80000, max_current: 121}  # TODO: Verify from datasheet

    # KTL-M Series (Modular)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - TODO: Verify from datasheet (calculated from max_ac_output_power / (phases * 220V))
    "SG30KTL-M": {phases: 3, mppt_count: 3, string_count: 3, type_code: "0x0141", max_ac_output_power: 30000, max_current: 45}  # TODO: Verify from datasheet
    "SG40KTL-M": {phases: 3, mppt_count: 3, string_count: 3, type_code: "0x0135", max_ac_output_power: 40000, max_current: 61}  # TODO: Verify from datasheet
    "SG50KTL-M": {phases: 3, mppt_count: 4, string_count: 3, type_code: "0x011B", max_ac_output_power: 50000, max_current: 76}  # TODO: Verify from datasheet
    "SG60KTL-M": {phases: 3, mppt_count: 4, string_count: 4, type_code: "0x0131", max_ac_output_power: 60000, max_current: 91}  # TODO: Verify from datasheet

    # CX Series (Commercial)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - from datasheet specifications (per phase)
    # References: DS_20200611_SG30CXAU_V11, SG125_110_75CX-P2-UEN-Ver14-202303
    "SG30CX": {phases: 3, mppt_count: 3, string_count: 2, type_code: "0x2C10", max_ac_output_power: 30000, max_current: 45}  # TODO: Verify from datasheet
    "SG33CX": {phases: 3, mppt_count: 3, string_count: 2, type_code: "0x2C00", max_ac_output_power: 33000, max_current: 55}  # Datasheet: 55.2A, rounded to 55A
    "SG40CX": {phases: 3, mppt_count: 4, string_count: 2, type_code: "0x2C01", max_ac_output_power: 40000, max_current: 67}  # Datasheet: 66.9A, rounded to 67A
    "SG50CX": {phases: 3, mppt_count: 5, string_count: 2, type_code: "0x2C02", max_ac_output_power: 50000, max_current: 84}  # Datasheet: 83.6A, rounded to 84A
    "SG75CX": {phases: 3, mppt_count: 9, string_count: 2, type_code: "0x2C22", max_ac_output_power: 75000, max_current: 114}  # TODO: Verify from datasheet (SG125_110_75CX-P2)
    "SG100CX": {phases: 3, mppt_count: 12, string_count: 2, type_code: "0x2C12", max_ac_output_power: 100000, max_current: 152}  # TODO: Verify from datasheet (SG125_110_75CX-P2)
    "SG110CX": {phases: 3, mppt_count: 9, string_count: 2, type_code: "0x2C06", max_ac_output_power: 110000, max_current: 159}  # Datasheet: 158.8A, rounded to 159A

    # HX Series (High Power)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - calculated from max_ac_output_power / (phases * 220V)
    "SG250HX": {phases: 3, mppt_count: 12, string_count: 2, type_code: "0x2C0C", max_ac_output_power: 250000, max_current: 379}
    "SG320HX": {phases: 3, mppt_count: 12, string_count: 2, type_code: "0x2C26", max_ac_output_power: 320000, max_current: 485}
    "SG350HX": {phases: 3, mppt_count: 12, string_count: 2, type_code: "0x2C27", max_ac_output_power: 350000, max_current: 530}

    # KTL Series (Additional models)
    # AC Output Power Limits: max_ac_output_power (W) - based on model kW rating
    # Max Current: max_current (A) - calculated from max_ac_output_power / (phases * 220V)
    "SG10KTL": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0x26", max_ac_output_power: 10000, max_current: 15}
    "SG12KTL": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0x29", max_ac_output_power: 12000, max_current: 18}
    "SG15KTL": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0x28", max_ac_output_power: 15000, max_current: 23}
    "SG20KTL": {phases: 3, mppt_count: 2, string_count: 3, type_code: "0x2A", max_ac_output_power: 20000, max_current: 30}

  firmware_version:
    description: "Firmware version string (e.g., 'SAPPHIRE-H_xxx')"
    options: ["SAPPHIRE-H_xxxx", "Latest"]
    default: "SAPPHIRE-H_xxxx"

  connection_type:
    description: "Connection type (LAN or WINET)"
    options: ["LAN", "WINET"]
    default: "LAN"

# Sensors for read access (Input Registers)
sensors:
  # Device Information
  - name: Protocol num
    unique_id: protocol_num
    group: "PV_device_info"
    address: 4949 # reg 4950-4951
    input_type: input
    data_type: uint32
    swap: word
    scan_interval: 3600
    entity_category: "diagnostic"

  - name: Protocol version raw
    unique_id: protocol_version_raw
    group: "PV_device_info"
    address: 4951 # reg 4952-4953
    input_type: input
    data_type: uint32
    swap: word
    scan_interval: 3600
    entity_category: "diagnostic"
    # Format: 0x01015300 = V1.1.53 (Major.Minor.Patch.Build); Logger forwarding not supported

  - name: Certification version of ARM Software
    unique_id: certification_version_arm_software
    group: "PV_device_info"
    address: 4953 # reg 4954-4968 (15 registers UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    icon: "mdi:certificate"
    entity_category: "diagnostic"
    # Certified version after finalizing electrical, safety regulations, and standards

  - name: Certification version of DSP Software
    unique_id: certification_version_dsp_software
    group: "PV_device_info"
    address: 4968 # reg 4969-4983 (15 registers UTF-8 string)
    input_type: input
    data_type: string
    count: 15
    scan_interval: 3600
    icon: "mdi:certificate"
    entity_category: "diagnostic"

  - name: Sungrow inverter serial
    unique_id: inverter_serial
    group: "PV_device_info"
    address: 4989 # reg 4990
    input_type: input
    data_type: string
    count: 10
    scan_interval: 600

  - name: Sungrow device type code
    unique_id: sungrow_device_type_code
    group: "PV_device_info"
    address: 4999 # reg 5000
    input_type: input
    data_type: uint16
    scan_interval: 600
    map:
      # SG Series Device Type Codes (from Communication Protocol V1.1.53)
      0x27: "SG30KTL"
      0x26: "SG10KTL"
      0x29: "SG12KTL"
      0x28: "SG15KTL"
      0x2A: "SG20KTL"
      0x2C: "SG30KU"
      0x2D: "SG36KTL"
      0x2E: "SG36KU"
      0x2F: "SG40KTL"
      0x0135: "SG40KTL-M"
      0x011B: "SG50KTL-M"
      0x0131: "SG60KTL-M"
      0x0136: "SG60KU"
      0x0141: "SG30KTL-M"
      0x70: "SG30KTL-M-V31"
      0x0134: "SG33KTL-M"
      0x74: "SG36KTL-M"
      0x013D: "SG33K3J"
      0x0137: "SG49K5J"
      0x72: "SG34KJ"
      0x73: "LP_P34KSG"
      0x010F: "SG60KTL"
      0x0138: "SG80KTL"
      0x0132: "SG60KU-M"
      0x0147: "SG5KTL-MT"
      0x0148: "SG6KTL-MT"
      0x013F: "SG8KTL-M"
      0x013E: "SG10KTL-M"
      0x2C0F: "SG10KTL-MT"
      0x013C: "SG12KTL-M"
      0x0142: "SG15KTL-M"
      0x0149: "SG17KTL-M"
      0x0143: "SG20KTL-M"
      0x0139: "SG80KTL-M"
      0x014C: "SG111HV"
      0x013B: "SG125HV"
      0x2C03: "SG125HV-20"
      0x2C10: "SG30CX"
      0x2C00: "SG33CX"
      0x2C0A: "SG36CX-US"
      0x2C01: "SG40CX"
      0x2C02: "SG50CX"
      0x2C0B: "SG60CX-US"
      0x2C21: "SG49.5CX-JP"
      0x2C06: "SG110CX"
      0x2C0C: "SG250HX"
      0x2C11: "SG250HX-US"
      0x2C12: "SG100CX"
      0x2C13: "SG250HX-IN"
      0x2C15: "SG25CX-SA"
      0x2C1C: "SG125HX"
      0x2C22: "SG75CX"
      # RT Series
      0x243D: "SG3.0RT"
      0x243E: "SG4.0RT"
      0x2430: "SG5.0RT"
      0x2431: "SG6.0RT"
      0x243C: "SG7.0RT"
      0x2432: "SG8.0RT"
      0x2433: "SG10RT"
      0x2434: "SG12RT"
      0x2435: "SG15RT"
      0x2436: "SG17RT"
      0x2437: "SG20RT"
      0x2438: "SG22RT"
      0x243B: "SG23RT"
      0x2439: "SG25RT"
      # RT-P2 Series
      0x244D: "SG3.0RT-P2"
      0x244E: "SG4.0RT-P2"
      0x2440: "SG5.0RT-P2"
      0x2441: "SG6.0RT-P2"
      0x244C: "SG7.0RT-P2"
      0x2442: "SG8.0RT-P2"
      0x2443: "SG10RT-P2"
      0x2444: "SG12RT-P2"
      0x2445: "SG15RT-P2"
      0x2446: "SG17RT-P2"
      0x2447: "SG20RT-P2"
      0x244B: "SG23RT-P2"
      0x2449: "SG25RT-P2"
      # RS Series
      0x260D: "SG5.5RS-JP"
      0x2600: "SG2.0RS-S"
      0x2601: "SG2.5RS-S"
      0x2602: "SG3.0RS-S"
      0x2603: "SG3.0RS"
      0x2604: "SG3.6RS"
      0x2605: "SG4.0RS"
      0x2606: "SG5.0RS"
      0x2607: "SG6.0RS"
      0x2608: "SG8.0RS"
      0x260E: "SG9.0RS"
      0x2609: "SG10RS"
      0x260F: "SG5.0RS-ADA"
      # HX Series
      0x2C25: "SG125HX-JP"
      0x2C26: "SG320HX"
      0x2C27: "SG350HX"
      0x2C2D: "SG125CX-P2"
      0x2C40: "SG110CX-P2"
      0x2C3F: "SG75CX-P2"
      0x2C43: "SG285HX"
      0x2C46: "SG333HX"
      0x2C4F: "SG350HX-US"
      # CX-P2 Series
      0x2C33: "SG25CX-P2"
      0x2C34: "SG30CX-P2"
      0x2C35: "SG33CX-P2"
      0x2C36: "SG36CX-P2"
      0x2C37: "SG40CX-P2"
      0x2C32: "SG50CX-P2"
    group: "PV_device_info"

  # SG-specific Basic Registers
  - name: Output type
    unique_id: output_type
    group: "PV_device_info"
    address: 5001 # reg 5002
    input_type: input
    data_type: uint16
    scan_interval: 600
    map:
      0: "Two phase"
      1: "3P4L"
      2: "3P3L"

  - name: Daily PV generation
    unique_id: daily_pv_generation
    group: "PV_daily_energy"
    address: 5002 # reg 5003
    input_type: input
    data_type: uint16
    scale: 0.1
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    scan_interval: 60
    icon: "mdi:solar-power"

  - name: Total PV generation
    unique_id: total_pv_generation
    group: "PV_total_energy"
    address: 5003 # reg 5004-5005
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    scan_interval: 300
    icon: "mdi:solar-power"

  - name: Total running time
    unique_id: total_running_time
    group: "PV_status"
    address: 5005 # reg 5006-5007
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "h"
    device_class: "duration"
    state_class: "total_increasing"
    scan_interval: 300
    icon: "mdi:clock"

  - name: Inverter temperature
    unique_id: inverter_temperature
    group: "PV_temperature"
    address: 5007 # reg 5008
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: Â°C
    device_class: "temperature"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Total apparent power
    unique_id: total_apparent_power
    group: "PV_total_power"
    address: 5008 # reg 5009-5010
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "VA"
    device_class: "apparent_power"
    state_class: measurement
    scan_interval: 5
    icon: "mdi:flash"
    condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG10KTL, SG12KTL, SG15KTL, SG20KTL, SG30KTL, SG36KTL, SG40KTL, SG60KTL, SG80KTL, SG30KTL-M, SG40KTL-M, SG50KTL-M, SG60KTL-M, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"

  # MPPT Data (will be filtered based on mppt_count)
  - name: MPPT1 voltage
    unique_id: mppt1_voltage
    group: "PV_mppt_voltage"
    address: 5010 # reg 5011
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT1 current
    unique_id: mppt1_current
    group: "PV_mppt_current"
    address: 5011 # reg 5012
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT2 voltage
    unique_id: mppt2_voltage
    group: "PV_mppt_voltage"
    address: 5012 # reg 5013
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 2"

  - name: MPPT2 current
    unique_id: mppt2_current
    group: "PV_mppt_current"
    address: 5013 # reg 5014
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 2"

  - name: MPPT3 voltage
    unique_id: mppt3_voltage
    group: "PV_mppt_voltage"
    address: 5014 # reg 5015
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 3"

  - name: MPPT3 current
    unique_id: mppt3_current
    group: "PV_mppt_current"
    address: 5015 # reg 5016
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 3"

  - name: Total DC power
    unique_id: total_dc_power
    group: "PV_total_dc_power"
    address: 5016 # reg 5017-5018
    input_type: input
    data_type: uint32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_total_dc_power"

  # Phase Data (will be filtered based on phases)
  - name: Phase A voltage
    unique_id: phase_a_voltage
    address: 5018 # reg 5019
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B voltage
    unique_id: phase_b_voltage
    address: 5019 # reg 5020
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "phases >= 2"

  - name: Phase C voltage
    unique_id: phase_c_voltage
    address: 5020 # reg 5021
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "phases >= 2"

  - name: Phase A current
    unique_id: phase_a_current
    address: 5021 # reg 5022
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B current
    unique_id: phase_b_current
    address: 5022 # reg 5023
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "phases >= 2"

  - name: Phase C current
    unique_id: phase_c_current
    address: 5023 # reg 5024
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "phases >= 2"

  - name: Total active power
    unique_id: total_active_power
    address: 5030 # reg 5031-5032
    input_type: input
    data_type: uint32
    swap: word
    precision: 0
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 5

  - name: Reactive power
    unique_id: reactive_power
    address: 5032 # reg 5033
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: "power"
    state_class: measurement
    scale: 1
    offset: 0
    scan_interval: 10
    group: "PV_power_measurement"

  - name: "Power Factor raw"
    unique_id: "power_factor_raw"
    address: 5034
    input_type: "input"
    data_type: "int16"
    precision: 3
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: measurement
    scale: 0.001
    scan_interval: 10

  - name: Grid frequency
    unique_id: grid_frequency
    group: "PV_grid_status"
    address: 5035 # reg 5036
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "Hz"
    device_class: "frequency"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_grid_status"

  - name: Work state
    unique_id: work_state
    address: 5037 # reg 5038
    input_type: input
    data_type: uint16
    scan_interval: 30
    map:
      0x0: "Run"
      0x8000: "Stop"
      0x1300: "Key stop"
      0x1500: "Emergency Stop"
      0x1400: "Standby"
      0x1200: "Initial standby"
      0x1600: "Starting"
      0x9100: "Alarm run"
      0x8100: "Derating run"
      0x8200: "Dispatch run"
      0x5500: "Fault"
      0x2500: "Communicate fault"
      0x1111: "Uninitialized"

  # Fault/Alarm code 1 - valid when work_state = Fault (0x5500) or Alarm (0x9100); See Appendix 3
  # - name: Fault alarm code 1
  #   unique_id: fault_alarm_code_1
  #   address: 5044 # reg 5045
  #   input_type: input
  #   data_type: uint16
  #   scan_interval: 30

  # Work State 2 (Appendix 2): U32 bit-based; flags key = bit position
  - name: "Running State"
    unique_id: "running_state"
    group: "PV_status"
    address: 5080 # reg 5081-5082
    condition: "selected_model != SG5.5RS-JP"
    input_type: input
    data_type: uint32
    swap: word
    state_class: measurement
    scan_interval: 10
    # Bit positions per Appendix 2; flags key = bit position
    flags:
      1: "Stop"
      2: "Initial standby"
      3: "Key stop"
      4: "Standby"
      5: "Emergency Stop"
      6: "Starting"
      9: "Fault"
      10: "Alarm run"
      11: "Derating run"
      12: "Dispatch run"
      13: "Communicate fault"
      17: "Run"
      18: "Total fault"

  # Registers 5082-5104 valid for KTL series only (Country set to Europe Area)
  - name: Meter active power raw
    unique_id: meter_active_power_raw
    address: 5082 # reg 5083-5084
    input_type: input
    data_type: int32
    swap: word
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 5
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Meter Phase A power
    unique_id: meter_phase_a_power
    address: 5084 # reg 5085-5086
    input_type: input
    data_type: int32
    swap: word
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 5
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Meter Phase B power
    unique_id: meter_phase_a_power
    address: 5086 # reg 5087-5088
    input_type: input
    data_type: int32
    swap: word
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 5
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Meter Phase C power
    unique_id: meter_phase_a_power
    address: 5088 # reg 5089-5090
    input_type: input
    data_type: int32
    swap: word
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 5
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"



  - name: "Load Power"
    unique_id: "load_power"
    group: "PV_load_power"
    address: 5090 # reg 5091-5092
    input_type: input
    data_type: int32
    swap: word
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "PV_load_power"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Daily exported energy
    unique_id: daily_exported_energy
    address: 5092 # reg 5093-5094
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    scale: 0.1
    scan_interval: 60
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Total exported energy
    unique_id: total_exported_energy
    address: 5094 # reg 5095-5096
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    scale: 0.1
    scan_interval: 300
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: "Daily Imported Energy"
    unique_id: "daily_imported_energy"
    group: "PV_energy_import"
    address: 5096 # reg 5097-5098
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    group: "PV_energy_import"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: "Total Imported Energy"
    unique_id: "total_imported_energy"
    group: "PV_energy_import"
    address: 5098 # reg 5099
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total
    scale: 1
    scan_interval: 600
    group: "PV_energy_import"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: "Daily Direct Energy Consumption"
    unique_id: "daily_direct_energy_consumption"
    group: "PV_energy_consumption"
    address: 5100 # reg 5101-5102
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600
    group: "PV_energy_consumption"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: "Total Direct Energy Consumption"
    unique_id: "total_direct_energy_consumption"
    group: "PV_energy_consumption"
    address: 5102 # reg 5103
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total
    scale: 1
    scan_interval: 600
    group: "PV_energy_consumption"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"

  - name: Daily running time
    unique_id: daily_running_time
    address: 5112 # reg 5113
    input_type: input
    data_type: uint16
    unit_of_measurement: "min"
    device_class: "duration"
    state_class: "total_increasing"
    scale: 1
    scan_interval: 300

  # - name: Present country
  #   unique_id: present_country
  #   address: 5113 # reg 5114
  #   input_type: input
  #   data_type: uint16
  #   scan_interval: 600

  # Extended MPPT sensors (4-12) - will be filtered based on mppt_count
  - name: MPPT4 voltage
    unique_id: mppt4_voltage
    group: "PV_mppt_voltage"
    address: 5114 # reg 5115
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 4"

  - name: MPPT4 current
    unique_id: mppt4_current
    group: "PV_mppt_current"
    address: 5115 # reg 5116
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 4"

  - name: MPPT5 voltage
    unique_id: mppt5_voltage
    group: "PV_mppt_voltage"
    address: 5116 # reg 5117
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 5"

  - name: MPPT5 current
    unique_id: mppt5_current
    group: "PV_mppt_current"
    address: 5117 # reg 5118
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 5"

  - name: MPPT6 voltage
    unique_id: mppt6_voltage
    group: "PV_mppt_voltage"
    address: 5118 # reg 5119
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 6"

  - name: MPPT6 current
    unique_id: mppt6_current
    group: "PV_mppt_current"
    address: 5119 # reg 5120
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    group: "PV_mppt"
    condition: "mppt_count >= 6"

  - name: Monthly PV generation
    unique_id: monthly_pv_generation
    address: 5127 # reg 5128-5129
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total_increasing"
    scale: 0.1
    scan_interval: 300

  # MPPT 7-12 sensors (continuation)
  - name: MPPT7 voltage
    unique_id: mppt7_voltage
    group: "PV_mppt_voltage"
    address: 5120 # reg 5121
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 7"

  - name: MPPT7 current
    unique_id: mppt7_current
    group: "PV_mppt_current"
    address: 5121 # reg 5122
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 7"

  - name: MPPT8 voltage
    unique_id: mppt8_voltage
    group: "PV_mppt_voltage"
    address: 5122 # reg 5123
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 8"

  - name: MPPT8 current
    unique_id: mppt8_current
    group: "PV_mppt_current"
    address: 5123 # reg 5124
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 8"

  - name: MPPT9 voltage
    unique_id: mppt9_voltage
    group: "PV_mppt_voltage"
    address: 5129 # reg 5130
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 9"

  - name: MPPT9 current
    unique_id: mppt9_current
    group: "PV_mppt_current"
    address: 5130 # reg 5131
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 9"

  - name: MPPT10 voltage
    unique_id: mppt10_voltage
    group: "PV_mppt_voltage"
    address: 5131 # reg 5132
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 10"

  - name: MPPT10 current
    unique_id: mppt10_current
    group: "PV_mppt_current"
    address: 5132 # reg 5133
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 10"

  - name: MPPT11 voltage
    unique_id: mppt11_voltage
    group: "PV_mppt_voltage"
    address: 5133 # reg 5134
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 11"

  - name: MPPT11 current
    unique_id: mppt11_current
    group: "PV_mppt_current"
    address: 5134 # reg 5135
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 11"

  - name: MPPT12 voltage
    unique_id: mppt12_voltage
    group: "PV_mppt_voltage"
    address: 5135 # reg 5136
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 12"

  - name: MPPT12 current
    unique_id: mppt12_current
    group: "PV_mppt_current"
    address: 5136 # reg 5137
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.1
    scan_interval: 10
    condition: "mppt_count >= 12"

  # Work Status registers
  - name: Work status 1
    unique_id: work_status_1
    address: 5139 # reg 5140
    input_type: input
    data_type: uint16
    scan_interval: 30
    condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"
    map:
      0: "Standby"
      1: "Running"
      2: "Derating"
      3: "Quota"
      4: "Scheduled outage"
      5: "Limit outage"
      6: "Error outage"

  - name: Work status 2
    unique_id: work_status_2
    address: 5140 # reg 5141
    input_type: input
    data_type: uint16
    scan_interval: 30
    condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"
    map:
      1: "Running"
      2: "Shut down"
      3: "Overhaul"
      4: "Standby"

  # Added with Version 1.1.50
  # type: input seems not to work, holding sends FFFF. consider to change to holding.
  #- name: Heart beat
  #  unique_id: heart_beat
  #  address: 5142 # reg 5143
  #  input_type: input
  #  data_type: uint16
  #  scan_interval: 30

  - name: Total PV Generation (high precision)
    unique_id: total_pv_generation_high_precision
    group: "PV_total_energy"
    address: 5143 # reg 5144-5145
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    scale: 0.1
    scan_interval: 300

  - name: Negative voltage to ground
    unique_id: negative_voltage_ground
    address: 5145 # reg 5146
    input_type: input
    data_type: int16
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 30

  - name: Bus voltage
    unique_id: bus_voltage
    address: 5146 # reg 5147
    input_type: input
    data_type: uint16
    unit_of_measurement: "V"
    device_class: "voltage"
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Grid frequency (high precision)
    unique_id: grid_frequency_hp
    address: 5147 # reg 5148
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "Hz"
    device_class: "frequency"
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  - name: PID work state
    unique_id: pid_work_state
    address: 5149 # reg 5150
    input_type: input
    data_type: uint16
    scan_interval: 60
    map:
      2: "PID Recover Operation"
      4: "Anti-PID Operation"
      8: "PID Abnormity"

  - name: PID alarm code
    unique_id: pid_alarm_code
    address: 5150 # reg 5151
    input_type: input
    data_type: uint16
    scan_interval: 60
    map:
      432: "PID resistance abnormal"
      433: "PID function abnormal"
      434: "PID overvoltage/overcurrent protection"


  # Following 2 registers are not in the documentation, but other projects are using them
  - name: Export power raw
    unique_id: export_power_raw
    address: 5216 # reg 5217-5218
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Meter Power raw
    unique_id: meter_power_raw
    address: 5218 # reg 5219-5220
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: "W"
    device_class: "power"
    state_class: measurement
    scale: 1
    scan_interval: 10

  # String Current sensors (7013-7044) - Important for diagnostics
  - name: String 1 current
    unique_id: string_1_current
    address: 7012 # reg 7013
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 1"

  - name: String 2 current
    unique_id: string_2_current
    address: 7013 # reg 7014
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 2"

  - name: String 3 current
    unique_id: string_3_current
    address: 7014 # reg 7015
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 3"

  - name: String 4 current
    unique_id: string_4_current
    address: 7015 # reg 7016
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 4"

  - name: String 5 current
    unique_id: string_5_current
    address: 7016 # reg 7017
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 5"

  - name: String 6 current
    unique_id: string_6_current
    address: 7017 # reg 7018
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 6"

  - name: String 7 current
    unique_id: string_7_current
    address: 7018 # reg 7019
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"
    condition: "string_count >= 7"

  - name: String 8 current
    unique_id: string_8_current
    condition: "string_count >= 8"
    address: 7019 # reg 7020
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "A"
    device_class: "current"
    state_class: measurement
    scale: 0.01
    scan_interval: 30
    group: "PV_strings"

# Controls for write access (Holding Registers)
controls:

  # # System Clock Controls
  # - type: "number"
  #   name: "System clock: Year"
  #   unique_id: "system_clock_year"
  #   address: 4999 # reg 5000
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # - type: "number"
  #   name: "System clock: Month"
  #   unique_id: "system_clock_month"
  #   address: 5000 # reg 5001
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # - type: "number"
  #   name: "System clock: Day"
  #   unique_id: "system_clock_day"
  #   address: 5001 # reg 5002
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # - type: "number"
  #   name: "System clock: Hour"
  #   unique_id: "system_clock_hour"
  #   address: 5002 # reg 5003
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # - type: "number"
  #   name: "System clock: Minute"
  #   unique_id: "system_clock_minute"
  #   address: 5003 # reg 5004
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # - type: "number"
  #   name: "System clock: Second"
  #   unique_id: "system_clock_second"
  #   address: 5004 # reg 5005
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"


  - type: "select"
    name: "Start/Stop Control"
    unique_id: "start_stop_control"
    address: 5005 # reg 5006
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0xCF: "Start"
      0xCE: "Stop"
    group: "PV_control"

  - type: "select"
    name: "Power Limitation Switch"
    unique_id: "power_limitation_switch"
    address: 5006 # reg 5007
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"

  - type: "number"
    name: "Power Limitation Setting"
    unique_id: "power_limitation_setting"
    address: 5007 # reg 5008
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "%"
    scale: 0.1
    min: 0
    max: 1000
    step: 1
    scan_interval: 30
    group: "PV_control"

  # Additional SG-specific control registers
  - type: "select"
    name: "Export Power Limitation"
    unique_id: "export_power_limitation"
    address: 5009 # reg 5010
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0xAA: "Enable"
      0x55: "Disable"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"

  - type: "number"
    name: "Export Power Limitation Value"
    unique_id: "export_power_limitation_value"
    address: 5010 # reg 5011
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "W"
    min: 0
    max_value: "{{max_ac_output_power}}"
    step: 100
    scan_interval: 30
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"
    # Placeholder will be replaced with model-specific value from dynamic_config.valid_models
    # For SG10RT: 10000 W, for SG20RT: 20000 W, for SG350HX: 350000 W

  - type: "number"
    name: "Current Transformer Output Current"
    unique_id: "ct_output_current"
    address: 5011 # reg 5012
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "A"
    min: 1
    max_value: 5
    step: 1
    scan_interval: 60
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"
    # Standard CT secondary current is 5A

  - type: "number"
    name: "Current Transformer Range"
    unique_id: "ct_range"
    address: 5012 # reg 5013
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "A"
    min: 1
    max_value: "{{max_current * 1.5}}"
    step: 1
    scan_interval: 60
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"
    # Placeholder will be replaced with model-specific value: max_current * 1.5 (50% safety margin)
    # For SG10RT: 15A * 1.5 = 23A, for SG350HX: 530A * 1.5 = 795A

  - type: "select"
    name: "Current Transformer Type"
    unique_id: "ct_type"
    address: 5013 # reg 5014
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 60
    options:
      0: "Internal"
      1: "External"
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"

  - type: "number"
    name: "Export Power Limitation Percentage"
    unique_id: "export_power_limitation_percentage"
    address: 5014 # reg 5015
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "%"
    scale: 0.1
    min: 0
    max: 100
    step: 0.1
    scan_interval: 30
    condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
    group: "PV_control"

  # - type: "number"
  #   name: "Installed PV Power"
  #   unique_id: "installed_pv_power"
  #   address: 5015 # reg 5016
  #   input_type: "holding"
  #   data_type: "uint16"
  #   unit_of_measurement: "kW"
  #   scale: 0.01
  #   min: 0
  #   max: 300
  #   step: 0.01
  #   scan_interval: 300
  #   condition: "selected_model in [SG5KTL-MT, SG6KTL-MT, SG8KTL-M, SG10KTL, SG10KTL-M, SG10KTL-MT, SG12KTL, SG12KTL-M, SG15KTL, SG15KTL-M, SG17KTL-M, SG20KTL, SG20KTL-M, SG30KTL, SG36KTL, SG40KTL, SG50KTL-M, SG60KTL-M, SG30KTL-M]"
  #   group: "PV_control"

  - type: "number"
    name: "Power Factor Setting"
    unique_id: "power_factor_setting"
    address: 5018 # reg 5019
    input_type: "holding"
    data_type: "int16"
    scale: 0.001
    min: -1.0
    max: 1.0
    step: 0.001
    scan_interval: 30
    group: "PV_control"
    depends_on_register:
      register_unique_id: "reactive_power_adjustment_mode"
      register_address: 5035  # Address of the dependency register
      required_value: 0xA1  # Available when reactive power adjustment mode is set to "Power factor setting" (0xA1)
    # Note: >0 means leading, <0 means lagging

  # Power Control Controls
  # Active Power Overload commented out: not all inverters support; needs testing; may depend on firmware
  # - type: "select"
  #   name: "Active Power Overload"
  #   unique_id: "active_power_overload"
  #   address: 5019 # reg 5020
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"
  #   options:
  #     0xAA: "Enable"
  #     0x55: "Disable"
  #   group: "PV_control"

  # - type: "number"
  #   name: "Local / remote control"
  #   unique_id: "local_remote_control"
  #   address: 5020 # reg 5021
  #   input_type: "holding"
  #   data_type: "uint16"
  #   scan_interval: 30
  #   group: "PV_control"

  # Grid Control Controls
  - type: "select"
    name: "Night SVG Switch"
    unique_id: "night_svg_switch"
    address: 5034 # reg 5035
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

  - type: "select"
    name: "Reactive power adjustment mode"
    unique_id: "reactive_power_adjustment_mode"
    address: 5035 # reg 5036
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "OFF"
      0xA1: "Power factor setting"
      0xA2: "Reactive power percentage"
      0xA3: "Q(P) curve"
      0xA4: "Q(U) curve"
    group: "PV_control"
    # Note: The SG5.5RS-JP doesn't support 0xA2, 0xA3, 0xA4

  - type: "number"
    name: "Reactive power percentage setting"
    unique_id: "reactive_power_percentage_setting"
    address: 5036 # reg 5037
    input_type: "holding"
    data_type: "int16"
    scan_interval: 30
    unit_of_measurement: "0.1%"
    group: "PV_control"
    # Note: Available when reactive power adjustment mode is set to 0xA2

  # Advanced Power Controls
  - type: "number"
    name: "Power limitation adjustment"
    unique_id: "power_limitation_adjustment"
    address: 5038 # reg 5039
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    unit_of_measurement: "0.1kW"
    group: "PV_control"
    # Note: Available when power limitation switch is enabled, Except SG5.5RS-JP

  - type: "number"
    name: "Reactive power adjustment"
    unique_id: "reactive_power_adjustment"
    address: 5039 # reg 5040
    input_type: "holding"
    data_type: "int16"
    scan_interval: 30
    unit_of_measurement: "0.1kVar"
    group: "PV_control"
    # Note: Check for valid inverters

  # PID Controls
  - type: "select"
    name: "PID Recovery"
    unique_id: "pid_recovery"
    address: 5040 # reg 5041
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG3.0RT, SG4.0RT, SG5.0RT, SG6.0RT, SG7.0RT, SG8.0RT, SG10RT, SG12RT, SG15RT, SG20RT, SG30CX, SG33CX, SG40CX, SG50CX, SG75CX, SG100CX, SG110CX, SG250HX, SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

  - type: "select"
    name: "Anti-PID"
    unique_id: "anti_pid"
    address: 5041 # reg 5042
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG250HX, SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

  - type: "select"
    name: "Full-Day PID Suppression"
    unique_id: "full_day_pid_suppression"
    address: 5042 # reg 5043
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG250HX, SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

  # Grid Dispatch Controls
  - type: "select"
    name: "Quick grid dispatch mode"
    unique_id: "quick_grid_dispatch_mode"
    address: 32568 # reg 32569
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

  - type: "select"
    name: "Swift grid dispatch mode"
    unique_id: "swift_grid_dispatch_mode"
    address: 32569 # reg 32570
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    condition: "selected_model in [SG320HX, SG350HX]"
    options:
      0xAA: "Enable"
      0x55: "Disable"
    group: "PV_control"
    # Note: Check for valid inverters

# Calculated Sensors
calculated:
  # Protocol Version (formatted) - from protocol_version_raw
  - name: "Protocol Version"
    unique_id: "protocol_version"
    type: "sensor"
    availability: "{{ not is_state('sensor.{PREFIX}_protocol_version_raw', 'unavailable') }}"
    state: >-
      {% set raw_value = states('sensor.{PREFIX}_protocol_version_raw') %}
      {% if raw_value in ['unavailable', 'unknown', 'None', ''] %}
        unknown
      {% else %}
        {% set raw = raw_value | int %}
        {% set major = (raw // 16777216) %}
        {% set minor = (raw // 65536) % 256 %}
        {% set patch = (raw // 256) % 256 %}
        V{{ major }}.{{ minor }}.{{ patch }}
      {% endif %}
    icon: "mdi:code-tags"
    group: "PV_device_info"
    entity_category: "diagnostic"

  # MPPT Power Calculations
  - name: "MPPT1 Power"
    unique_id: "mppt1_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt1_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt1_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt1_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT2 Power"
    unique_id: "mppt2_power"
    type: "sensor"
    condition: "mppt_count >= 2"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt2_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt2_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt2_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT3 Power"
    unique_id: "mppt3_power"
    type: "sensor"
    condition: "mppt_count >= 3"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt3_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt3_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt3_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt3_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  # Extended MPPT Power calculations (4-12)
  - name: "MPPT4 Power"
    unique_id: "mppt4_power"
    type: "sensor"
    condition: "mppt_count >= 4"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt4_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt4_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt4_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt4_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT5 Power"
    unique_id: "mppt5_power"
    type: "sensor"
    condition: "mppt_count >= 5"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt5_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt5_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt5_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt5_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT6 Power"
    unique_id: "mppt6_power"
    type: "sensor"
    condition: "mppt_count >= 6"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt6_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt6_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt6_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt6_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "Total MPPT Power"
    unique_id: "total_mppt_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt1_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt1_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt3_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt3_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt4_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt4_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt5_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt5_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt6_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt6_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt7_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt7_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt8_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt8_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt9_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt9_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt10_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt10_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt11_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt11_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt12_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt12_current', 'unavailable')
      }}
    state: >-
      {% set mppt1_voltage = states('sensor.{PREFIX}_mppt1_power_mppt1_voltage') %}
      {% set mppt1_current = states('sensor.{PREFIX}_mppt1_current') %}
      {% set mppt2_voltage = states('sensor.{PREFIX}_mppt2_voltage') %}
      {% set mppt2_current = states('sensor.{PREFIX}_mppt2_current') %}
      {% set mppt3_voltage = states('sensor.{PREFIX}_mppt3_voltage') %}
      {% set mppt3_current = states('sensor.{PREFIX}_mppt3_current') %}
      {% set mppt4_voltage = states('sensor.{PREFIX}_mppt4_voltage') %}
      {% set mppt4_current = states('sensor.{PREFIX}_mppt4_current') %}
      {% set mppt5_voltage = states('sensor.{PREFIX}_mppt5_voltage') %}
      {% set mppt5_current = states('sensor.{PREFIX}_mppt5_current') %}
      {% set mppt6_voltage = states('sensor.{PREFIX}_mppt6_voltage') %}
      {% set mppt6_current = states('sensor.{PREFIX}_mppt6_current') %}
      {% set mppt7_voltage = states('sensor.{PREFIX}_mppt7_voltage') %}
      {% set mppt7_current = states('sensor.{PREFIX}_mppt7_current') %}
      {% set mppt8_voltage = states('sensor.{PREFIX}_mppt8_voltage') %}
      {% set mppt8_current = states('sensor.{PREFIX}_mppt8_current') %}
      {% set mppt9_voltage = states('sensor.{PREFIX}_mppt9_voltage') %}
      {% set mppt9_current = states('sensor.{PREFIX}_mppt9_current') %}
      {% set mppt10_voltage = states('sensor.{PREFIX}_mppt10_voltage') %}
      {% set mppt10_current = states('sensor.{PREFIX}_mppt10_current') %}
      {% set mppt11_voltage = states('sensor.{PREFIX}_mppt11_voltage') %}
      {% set mppt11_current = states('sensor.{PREFIX}_mppt11_current') %}
      {% set mppt12_voltage = states('sensor.{PREFIX}_mppt12_voltage') %}
      {% set mppt12_current = states('sensor.{PREFIX}_mppt12_current') %}

      {% set mppt1_power = (mppt1_voltage | float(0)) * (mppt1_current | float(0)) %}
      {% set mppt2_power = (mppt2_voltage | float(0)) * (mppt2_current | float(0)) %}
      {% set mppt3_power = (mppt3_voltage | float(0)) * (mppt3_current | float(0)) %}
      {% set mppt4_power = (mppt4_voltage | float(0)) * (mppt4_current | float(0)) %}
      {% set mppt5_power = (mppt5_voltage | float(0)) * (mppt5_current | float(0)) %}
      {% set mppt6_power = (mppt6_voltage | float(0)) * (mppt6_current | float(0)) %}
      {% set mppt7_power = (mppt7_voltage | float(0)) * (mppt7_current | float(0)) %}
      {% set mppt8_power = (mppt8_voltage | float(0)) * (mppt8_current | float(0)) %}
      {% set mppt9_power = (mppt9_voltage | float(0)) * (mppt9_current | float(0)) %}
      {% set mppt10_power = (mppt10_voltage | float(0)) * (mppt10_current | float(0)) %}
      {% set mppt11_power = (mppt11_voltage | float(0)) * (mppt11_current | float(0)) %}
      {% set mppt12_power = (mppt12_voltage | float(0)) * (mppt12_current | float(0)) %}

      {{ mppt1_power + mppt2_power + mppt3_power + mppt4_power + mppt5_power + mppt6_power + mppt7_power + mppt8_power + mppt9_power + mppt10_power + mppt11_power + mppt12_power }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_total_power"

  - name: "Import Power"
    unique_id: "import_power"
    type: "sensor"
    availability: "{{ not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable') }}"
    state: >-
      {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
      {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
        0
      {% elif (export_power|int) < 0 %}
        {{ (export_power|int) *-1 }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_grid_power"

  - name: "Export Power"
    unique_id: "export_power"
    type: "sensor"
    availability: "{{states('sensor.{PREFIX}_export_power_raw')|is_number }}"
    state: >-
      {% if states('sensor.{PREFIX}_export_power_raw')|int > 0 %}
        {{ states('sensor.{PREFIX}_export_power_raw') }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_grid_power"

  - name: "Total Load Power"
    unique_id: "total_load_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_load_power', 'unavailable') }}
    state: "{{ states('sensor.{PREFIX}_load_power') | float(0) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_load_power"

  # System Efficiency Calculations
  - name: "Solar to Grid Efficiency"
    unique_id: "solar_to_grid_efficiency"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and (not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
           or not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable'))
      }}
    state: >-
      {% set pv = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% if not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') %}
        {% set grid = states('sensor.{PREFIX}_meter_active_power_raw') | float(0) %}
      {% elif not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable') %}
        {% set grid = states('sensor.{PREFIX}_power_meter_raw') | float(0) %}
      {% else %}
        {% set grid = 0 %}
      {% endif %}
      {% if pv > 0 and grid < 0 %}{{ (grid | abs / pv * 100) | round(1) }}{% else %}0{% endif %}
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    group: "PV_efficiency"

  - name: "Battery to Load Efficiency"
    unique_id: "battery_to_load_efficiency"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: "{% set pv = states('sensor.{PREFIX}_total_pv_generation') | float(0) %}{% set load = states('sensor.{PREFIX}_load_power') | float(0) %}{% if pv > 0 %}{{ (load / pv * 100) | round(1) }}{% else %}0{% endif %}"
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    group: "PV_efficiency"

  # Power Balance Calculations
  - name: "Power Balance"
    unique_id: "power_balance"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      and (not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
           or not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable'))
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: >-
      {% set dc_power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% if not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') %}
        {% set grid_power = states('sensor.{PREFIX}_meter_active_power_raw') | float(0) %}
      {% elif not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable') %}
        {% set grid_power = states('sensor.{PREFIX}_power_meter_raw') | float(0) %}
      {% else %}
        {% set grid_power = 0 %}
      {% endif %}
      {% set load_power = states('sensor.{PREFIX}_load_power') | float(0) %}
      {{ dc_power + grid_power - load_power }}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_power_balance"

  # Individual Phase Power Calculations
  - name: "Phase A Power"
    unique_id: "phase_a_power"
    group: "PV_phase_power"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_a_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_a_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_a_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_a_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_phase_power"

  - name: "Phase B Power"
    unique_id: "phase_b_power"
    group: "PV_phase_power"
    type: "sensor"
    condition: "phases >= 2"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_b_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_b_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_b_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_b_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_phase_power"

  - name: "Phase C Power"
    unique_id: "phase_c_power"
    group: "PV_phase_power"
    type: "sensor"
    condition: "phases >= 2"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_phase_c_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_phase_c_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_c_voltage') | float(0)) * (states('sensor.{PREFIX}_phase_c_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_phase_power"

  # calculated sensor in case the meter is not available (grid is off) and returns 0x7FFFFF
  - name: "Meter Active Power"
    unique_id: "meter_active_power"
    type: "sensor"
    availability: >-
      {{
      (not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
       and states('sensor.{PREFIX}_meter_active_power_raw')|int(0) != 0x7FFFFFFF)
      or (not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable')
          and states('sensor.{PREFIX}_power_meter_raw')|int(0) != 0x7FFFFFFF)
      }}
    state: >-
      {% if not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
            and states('sensor.{PREFIX}_meter_active_power_raw')|int(0) != 0x7FFFFFFF %}
        {{ states('sensor.{PREFIX}_meter_active_power_raw') }}
      {% elif not is_state('sensor.{PREFIX}_power_meter_raw', 'unavailable')
            and states('sensor.{PREFIX}_power_meter_raw')|int(0) != 0x7FFFFFFF %}
        {{ states('sensor.{PREFIX}_power_meter_raw') }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"

  # Energy Consumption Calculations
  - name: "Daily consumed energy"
    unique_id: "daily_consumed_energy"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_daily_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_exported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_daily_imported_energy', 'unavailable')
      }}
    state: >-
      {{
        (
          states('sensor.{PREFIX}_daily_pv_generation')|float
          - states('sensor.{PREFIX}_daily_exported_energy')|float
          + states('sensor.{PREFIX}_daily_imported_energy')|float
        )
      }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    group: "PV_daily_consumed_energy"

  - name: "Total consumed energy"
    unique_id: "total_consumed_energy"
    type: "sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_total_pv_generation', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_exported_energy', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_imported_energy', 'unavailable')
      }}
    state: >-
      {{
        (
          states('sensor.{PREFIX}_total_pv_generation')|float
          - states('sensor.{PREFIX}_total_exported_energy')|float
          + states('sensor.{PREFIX}_total_imported_energy')|float
        )
      }}
    unit_of_measurement: "kWh"
    device_class: "energy"
    state_class: "total"
    group: "PV_total_consumed_energy"

  ## some additional calculated sensors ideas
  - name: "Inverter Status Display"
    unique_id: "inverter_status_display"
    type: "sensor"
    availability: >-
      {{
      states('sensor.{PREFIX}_total_dc_power') not in ['unknown', 'unavailable']
      and states('sensor.{PREFIX}_inverter_temperature') not in ['unknown', 'unavailable']
      }}
    state: >-
      {% set power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set temp = states('sensor.{PREFIX}_inverter_temperature') | float(0) %}
      {% if power > 1000 %}
        High Production
      {% elif power > 100 %}
        Normal Production
      {% elif power > 0 %}
        Low Production
      {% else %}
        Standby
      {% endif %}
    icon_template: >-
      {% set power = states('sensor.{PREFIX}_total_dc_power') | float(0) %}
      {% set temp = states('sensor.{PREFIX}_inverter_temperature') | float(0) %}
      {% if temp > 70 %}
        mdi:alert-circle
      {% elif power > 1000 %}
        mdi:solar-power
      {% elif power > 100 %}
        mdi:solar-panel
      {% elif power > 0 %}
        mdi:solar-panel-large
      {% else %}
        mdi:power-sleep
      {% endif %}
    group: "PV_status"

  - name: "Grid Status"
    unique_id: "grid_status"
    type: "sensor"
    availability: >-
      {{
      states('sensor.{PREFIX}_meter_active_power') not in ['unknown', 'unavailable']
      }}
    state: >-
      {% set import_power = states('sensor.{PREFIX}_meter_active_power') | float(0) %}
      {% if import_power > 100 %}
        Importing
      {% elif import_power < -100 %}
        Exporting
      {% else %}
        Balanced
      {% endif %}
    icon_template: >-
      {% set import_power = states('sensor.{PREFIX}_meter_active_power') | float(0) %}
      {% if import_power > 500 %}
        mdi:transmission-tower-import
      {% elif import_power > 100 %}
        mdi:transmission-tower
      {% elif import_power < -500 %}
        mdi:transmission-tower-export
      {% elif import_power < -100 %}
        mdi:transmission-tower-off
      {% else %}
        mdi:scale-balance
      {% endif %}
    group: "PV_grid_status"

  # Additional MPPT Power Calculations (MPPT 7-16)
  - name: "MPPT7 Power"
    unique_id: "mppt7_power"
    type: "sensor"
    condition: "mppt_count >= 7"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt7_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt7_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt7_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt7_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT8 Power"
    unique_id: "mppt8_power"
    type: "sensor"
    condition: "mppt_count >= 8"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt8_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt8_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt8_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt8_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT9 Power"
    unique_id: "mppt9_power"
    type: "sensor"
    condition: "mppt_count >= 9"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt9_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt9_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt9_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt9_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT10 Power"
    unique_id: "mppt10_power"
    type: "sensor"
    condition: "mppt_count >= 10"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt10_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt10_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt10_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt10_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT11 Power"
    unique_id: "mppt11_power"
    type: "sensor"
    condition: "mppt_count >= 11"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt11_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt11_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt11_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt11_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

  - name: "MPPT12 Power"
    unique_id: "mppt12_power"
    type: "sensor"
    condition: "mppt_count >= 12"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_mppt12_voltage', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt12_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt12_voltage') | float(0)) * (states('sensor.{PREFIX}_mppt12_current') | float(0)) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "PV_mppt_power"

# Binary Sensors
binary_sensors:
  # Binary Sensors for Status Monitoring
  - name: "PV generating"
    unique_id: "pv_generating"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int |bitwise_and(0x1)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set total_dc_power = states('sensor.{PREFIX}_total_dc_power') %}
        {% if total_dc_power in ['unknown', 'unavailable', 'none'] or total_dc_power is none %}
          0
        {% elif (total_dc_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "PV generating (delay)"
    unique_id: "pv_generating_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_pv_generating', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_pv_generating') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Exporting power"
    unique_id: "exporting_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_export_power_raw', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x10)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
        {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
          0
        {% elif (export_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "battery"
    group: "PV_binary_status"

  - name: "Exporting power (delay)"
    unique_id: "exporting_power_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_exporting_power', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_exporting_power') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Importing power"
    unique_id: "importing_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      and not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x20)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set export_power = states('sensor.{PREFIX}_export_power_raw') %}
        {% if export_power in ['unknown', 'unavailable', 'none'] or export_power is none %}
          0
        {% elif (export_power|int) < 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "Importing power (delay)"
    unique_id: "importing_power_delay"
    type: "binary_sensor"
    availability: "{{ not is_state('binary_sensor.{PREFIX}_importing_power', 'unavailable') }}"
    delay_on:
      seconds: 60
    state: "{{ states('binary_sensor.{PREFIX}_importing_power') }}"
    device_class: "power"
    group: "PV_binary_status"

  - name: "Positive load power"
    unique_id: "positive_load_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x8)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set load_power = states('sensor.{PREFIX}_load_power') %}
        {% if load_power in ['unknown', 'unavailable', 'none'] or load_power is none %}
          0
        {% elif (load_power|int) > 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"

  - name: "Negative load power"
    unique_id: "negative_load_power"
    type: "binary_sensor"
    availability: >-
      {{
      not is_state('sensor.{PREFIX}_running_state', 'unavailable')
      }}
    state: >-
      {% if states('sensor.{PREFIX}_running_state')|is_number and states('sensor.{PREFIX}_running_state')|float > 0 %}
        {# use available sensor running_state #}
        {{ (states('sensor.{PREFIX}_running_state')|int|bitwise_and(0x80)) > 0 }}
      {% else %}
        {# workaround for SH*RS inverters without working running_state #}
        {% set load_power = states('sensor.{PREFIX}_load_power') %}
        {% if load_power in ['unknown', 'unavailable', 'none'] or load_power is none %}
          0
        {% elif (load_power|int) < 0 %}
          1
        {% else %}
          0
        {% endif %}
      {% endif %}
    device_class: "power"
    group: "PV_binary_status"
