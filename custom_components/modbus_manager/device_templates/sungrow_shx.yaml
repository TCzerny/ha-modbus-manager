# Sungrow SHx Inverter Template für Modbus Manager
# BASIEREND AUF: https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant
# WICHTIG: ALLE Register wurden 100% exakt übernommen - keine Änderungen an den Register-Definitionen
# Nur das Format wurde an Modbus Manager angepasst

name: "Sungrow SHx Inverter"
description: "Template für Sungrow SHx Wechselrichter über Modbus TCP - KOMPLETT übernommen von mkaiser"
manufacturer: "Sungrow"
model: "SHx Series"

sensors:
  - name: Sungrow inverter serial
    unique_id: inverter_serial
    address: 4989 # reg 4990
    input_type: input
    data_type: string
    count: 10
    scan_interval: 600
    group: "device_count"

  - name: Sungrow device type code
    unique_id: dev_code
    address: 4999 # reg 5000
    input_type: input
    data_type: uint16
    scan_interval: 600
    map:
      3334: "SH3K6"
      3335: "SH4K6"
      3337: "SH5K-20"
      3331: "SH5K-V13"
      3338: "SH3K6-30"
      3339: "SH4K6-30"
      3340: "SH5K-30"
      3351: "SH3.0RS"
      3341: "SH3.6RS"
      3352: "SH4.0RS"
      3343: "SH5.0RS"
      3344: "SH6.0RS"
      3354: "SH8.0RS"
      3355: "SH10RS"
      3584: "SH5.0RT"
      3585: "SH6.0RT"
      3586: "SH8.0RT"
      3587: "SH10RT"
      3600: "SH5.0RT-20"
      3601: "SH6.0RT-20"
      3602: "SH8.0RT-20"
      3603: "SH10RT-20"
      3596: "SH5.0RT-V112"
      3597: "SH6.0RT-V112"
      3598: "SH8.0RT-V112"
      3599: "SH10RT-V112"
      3592: "SH5.0RT-V122"
      3593: "SH6.0RT-V122"
      3594: "SH8.0RT-V122"
      3595: "SH10RT-V122"
      3616: "SH5T"
      3617: "SH6T"
      3618: "SH8T"
      3619: "SH10T"
      3620: "SH12T"
      3621: "SH15T"
      3622: "SH20T"
      3624: "SH25T"
      3351: "MG5RL"
      3352: "MG6RL"

  - name: Daily PV generation & battery discharge
    unique_id: daily_pv_gen_battery_discharge
    address: 5002 # reg 5003
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total PV generation & battery discharge
    unique_id: total_pv_gen_battery_discharge

    address: 5003 # reg 5004
    input_type: input
    data_type: uint32
    swap: word
    unit_of_measurement: kWh
    precision: 1
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Inverter temperature
    unique_id: inverter_temperature

    address: 5007 # reg 5008
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: °C
    device_class: temperature
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT1 voltage
    unique_id: mppt1_voltage

    address: 5010 # reg 5011
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT1 current
    unique_id: mppt1_current

    address: 5011 # reg 5012
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: Current
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT2 voltage
    unique_id: mppt2_voltage
    address: 5012 # reg 5013
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: MPPT2 current
    unique_id: mppt2_current
    address: 5013 # reg 5014
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: A
    device_class: Current
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  # only for SH*T inverters with 3 MPPTs
  # - name: MPPT3 voltage
  #   unique_id: mppt3_voltage
  #
  #   address: 5014 # reg 5015
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: V
  #   device_class: Voltage
  #   state_class: measurement
  #   scale: 0.1
  #   scan_interval: 10

  # only for SH*T inverters with 3 MPPTs
  # - name: MPPT3 current
  #   unique_id: mppt3_current
  #
  #   address: 5015 # reg 5016
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: A
  #   device_class: Current
  #   state_class: measurement
  #   scale: 0.1
  #   scan_interval: 10

  - name: Total DC power
    unique_id: total_dc_power

    address: 5016 # reg 5017
    input_type: input
    data_type: uint32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10
    group: "total_dc_power"

  - name: Phase A voltage
    unique_id: phase_a_voltage
    address: 5018 # reg: 5019
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B voltage
    unique_id: phase_b_voltage
    address: 5019 # reg: 5020
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase C voltage
    unique_id: phase_c_voltage

    address: 5020 # reg: 5021
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Reactive power
    unique_id: reactive_power
    address: 5032 # reg 5033
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    offset: 0
    scan_interval: 10
    # Debug: Add validation for int32 values
    group: "power_measurement"

  - name: Power factor
    unique_id: power_factor
    address: 5034 # reg 5035
    input_type: input
    data_type: int16
    precision: 3
    unit_of_measurement: "%"
    device_class: power_factor
    state_class: measurement
    scale: 0.001
    scan_interval: 10

  - name: Grid frequency
    unique_id: grid_frequency
    address: 5241 # reg 5242
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: "Hz"
    device_class: frequency
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  #https://www.photovoltaikforum.com/thread/166134-daten-lesen-vom-sungrow-wechselrichtern-modbus/?pageNo=13
  #Meter Active Power: 5601-5602 S32 W (Energiezähler Wirkleistung)
  #Meter Phase A Active Power: 5603-5604 S32 W (Stromzähler Phase A Wirkleistung)
  #Meter Phase B Active Power: 5605-5606 S32 W (Stromzähler Phase B Wirkleistung)
  #Meter Phase C Active Power: 5607-5608 S32 W (Stromzähler Phase C Wirkleistung)
  - name: Meter active power raw
    unique_id: meter_active_power_raw

    address: 5600 # reg 5601
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Meter phase A active power raw
    unique_id: meter_phase_a_active_power_raw

    address: 5602 # reg 5603
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Meter phase B active power raw
    unique_id: meter_phase_b_active_power_raw

    address: 5604 # reg 5605
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Meter phase C active power raw
    unique_id: meter_phase_c_active_power_raw

    address: 5606 # reg 5607
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: BDC rated power
    unique_id: bdc_rated_power

    address: 5627 # reg 5628
    input_type: input
    data_type: uint16
    unit_of_measurement: "W"
    device_class: power
    state_class: measurement
    scale: 100
    scan_interval: 600

  - name: BMS max. charging current
    unique_id: bms_max_charging_current

    address: 5634 # reg 5635
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: A
    device_class: Current
    state_class: measurement
    scale: 1
    scan_interval: 60

  - name: BMS max. discharging current
    unique_id: bms_max_discharging_current

    address: 5635 # reg 5636
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: A
    device_class: Current
    state_class: measurement
    scale: 1
    scan_interval: 60

  - name: Battery capacity # as in TI_20240924_Communication Protocol of Residential Hybrid Inverter-V1.1.5
    unique_id: battery_capacity

    address: 5638 # reg 5639
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: kWh
    device_class: energy_storage
    scale: 0.01
    scan_interval: 600

  #https://www.photovoltaikforum.com/thread/166134-daten-lesen-vom-sungrow-wechselrichtern-modbus/?pageNo=13
  #Phase A Backup Power: 5723 S16 W (Backup Leistung Phase A)
  #Phase B Backup Power: 5724 S16 W (Backup Leistung Phase B)
  #Phase C Backup Power: 5725 S16 W (Backup Leistung Phase C)
  - name: Backup phase A power
    unique_id: backup_phase_a_power

    address: 5722 # reg 5723
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Backup phase B power
    unique_id: backup_phase_b_power

    address: 5723 # reg 5724
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Backup phase C power
    unique_id: backup_phase_c_power

    address: 5724 # reg 5725
    input_type: input
    data_type: int16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Total backup power

    unique_id: total_backup_power
    address: 5725 # reg 5726
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10


  # https://www.photovoltaikforum.com/thread/166134-daten-lesen-vom-sungrow-wechselrichtern-modbus/?postID=3324464#post3324464
  - name: Meter phase A voltage
    unique_id: meter_phase_a_voltage

    address: 5740 # reg 5741
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Meter phase B voltage
    unique_id: meter_phase_b_voltage

    address: 5741 # reg 5742
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Meter phase C voltage
    unique_id: meter_phase_c_voltage

    address: 5742 # reg 5743
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: V
    device_class: voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Meter phase A current
    unique_id: meter_phase_a_current

    address: 5743 # reg 5744
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  - name: Meter phase B current
    unique_id: meter_phase_b_current

    address: 5744 # reg 5745
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.01
    scan_interval: 10

  - name: Meter phase C current
    unique_id: meter_phase_c_current

    address: 5745 # reg 5746
    input_type: input
    data_type: uint16
    precision: 2
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.01
    scan_interval: 10


  # following statistic sensors only work on some SH*RT inverters
  # (only LAN attached devices)
  # Therefore commenting them here
  # # Start monthly PV generation
  # - name: Monthly PV generation (01 January)
  #   unique_id: monthly_pv_generation_01_january
  #
  #   address: 6226 # reg 6227
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (02 February)
  #   unique_id: monthly_pv_generation_02_february
  #
  #   address: 6227 # reg 6228
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (03 March)
  #   unique_id: monthly_pv_generation_03_march
  #
  #   address: 6228 # reg 6229
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (04 April)
  #   unique_id: monthly_pv_generation_04_april
  #
  #   address: 6229 # reg 6230
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (05 May)
  #   unique_id: monthly_pv_generation_05_may
  #
  #   address: 6230 # reg 6231
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (06 June)
  #   unique_id: monthly_pv_generation_06_june
  #
  #   address: 6231 # reg 6232
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (07 July)
  #   unique_id: monthly_pv_generation_07_july
  #
  #   address: 6232 # reg 6233
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (08 August)
  #   unique_id: monthly_pv_generation_08_august
  #
  #   address: 6233 # reg 6234
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (09 September)
  #   unique_id: monthly_pv_generation_09_september
  #
  #   address: 6234 # reg 6235
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (10 October)
  #   unique_id: monthly_pv_generation_10_october
  #
  #   address: 6235 # reg 6236
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (11 November)
  #   unique_id: monthly_pv_generation_11_november
  #
  #   address: 6236 # reg 6237
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly PV generation (12 December)
  #   unique_id: monthly_pv_generation_12_december
  #
  #   address: 6237 # reg 6238
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600
  # # End monthly PV generation

  # # Start yearly pv generation
  # - name: Yearly PV generation (2019)
  #   unique_id: yearly_pv_generation_2019
  #
  #   address: 6257 # reg 6258
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2020)
  #   unique_id: yearly_pv_generation_2020
  #
  #   address: 6259 # reg 6260
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2021)
  #   unique_id: yearly_pv_generation_2021
  #
  #   address: 6261 # reg 6262
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2022)
  #   unique_id: yearly_pv_generation_2022
  #
  #   address: 6263 # reg 6264
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2023)
  #   unique_id: yearly_pv_generation_2023
  #
  #   address: 6265 # reg 6266
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2024)
  #   unique_id: yearly_pv_generation_2024
  #
  #   address: 6267 # reg 6268
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2025)
  #   unique_id: yearly_pv_generation_2025
  #
  #   address: 6269 # reg 6270
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2026)
  #   unique_id: yearly_pv_generation_2026
  #
  #   address: 6271 # reg 6272
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2027)
  #   unique_id: yearly_pv_generation_2027
  #
  #   address: 6273 # reg 6274
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2028)
  #   unique_id: yearly_pv_generation_2028
  #
  #   address: 6275 # reg 6276
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly PV generation (2029)
  #   unique_id: yearly_pv_generation_2029
  #
  #   address: 6277 # reg 6278
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600
  # # End yearly pv generation

  # # Start monthly export
  # - name: Monthly export (01 January)
  #   unique_id: monthly_export_01_january
  #
  #   address: 6595 # reg 6596
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (02 February)
  #   unique_id: monthly_export_02_february
  #
  #   address: 6596 # reg 6597
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (03 March)
  #   unique_id: monthly_export_03_march
  #
  #   address: 6597 # reg 6598
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (04 April)
  #   unique_id: monthly_export_04_april
  #
  #   address: 6598 # reg 6599
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (05 May)
  #   unique_id: monthly_export_05_may
  #
  #   address: 6599 # reg 6600
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (06 June)
  #   unique_id: monthly_export_06_june
  #
  #   address: 6600 # reg 6601
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (07 July)
  #   unique_id: monthly_export_07_july
  #
  #   address: 6601 # reg 6602
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (08 August)
  #   unique_id: monthly_export_08_august
  #
  #   address: 6602 # reg 6603
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (09 September)
  #   unique_id: monthly_export_09_september
  #
  #   address: 6603 # reg 6604
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (10 October)
  #   unique_id: monthly_export_10_october
  #
  #   address: 6604 # reg 6605
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (11 November)
  #   unique_id: monthly_export_11_november
  #
  #   address: 6605 # reg 6606
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Monthly export (12 December)
  #   unique_id: monthly_export_12_december
  #
  #   address: 6606 # reg 6607
  #   input_type: input
  #   data_type: uint16
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total_increasing
  #   scale: 0.1
  #   scan_interval: 600
  # # End monthly export

  # # Start yearly export energy from PV
  # - name: Yearly Export (2019)
  #   unique_id: yearly_export_2019
  #
  #   address: 6615 # reg 6616
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2020)
  #   unique_id: yearly_export_2020
  #
  #   address: 6617 # reg 6618
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2021)
  #   unique_id: yearly_export_2021
  #
  #   address: 6619 # reg 6620
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2022)
  #   unique_id: yearly_export_2022
  #
  #   address: 6621 # reg 6622
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2023)
  #   unique_id: yearly_export_2023
  #
  #   address: 6623 # reg 6624
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2024)
  #   unique_id: yearly_export_2024
  #
  #   address: 6625 # reg 6626
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2025)
  #   unique_id: yearly_export_2025
  #
  #   address: 6627 # reg 6628
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2026)
  #   unique_id: yearly_export_2026
  #
  #   address: 6629 # reg 6630
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2027)
  #   unique_id: yearly_export_2027
  #
  #   address: 6631 # reg 6632
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600

  # - name: Yearly Export (2028)
  #   unique_id: yearly_export_2028
  #
  #   address: 6633 # reg 6634
  #   input_type: input
  #   data_type: uint32
  #   swap: word
  #   precision: 1
  #   unit_of_measurement: kWh
  #   device_class: energy
  #   state_class: total
  #   scale: 0.1
  #   scan_interval: 600
  # # End yearly export energy from PV


  - name: "System state"
    unique_id: "system_state"
    address: 12999
    input_type: "input"
    data_type: "uint16"
    scan_interval: 10
    flags:
      0: "Grid Connected"
      1: "Battery Active"
      2: "Solar Active"
      3: "Load Active"
      4: "Charging"
      5: "Discharging"
      6: "Error Active"
      7: "Maintenance Mode"
    group: "status"



  - name: "Load Adjustment Mode"
    unique_id: "load_adjustment_mode"
    address: 13001
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    map:
      0: "Timing"
      1: "ON/OFF"
      2: "Power optimization"
      3: "Disabled"
    group: "modes"


  - name: Daily PV generation
    unique_id: daily_pv_generation

    address: 13001 # reg 13002
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total PV generation
    unique_id: total_pv_generation

    address: 13002 # reg 13003
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily exported energy from PV
    unique_id: daily_exported_energy_from_PV

    address: 13004 # reg 13005
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total exported energy from PV
    unique_id: total_exported_energy_from_pv

    address: 13005 # reg 13006
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Load power
    unique_id: load_power

    address: 13007 # reg 13008
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  # this value returns a positive value when exporting and a negative value when importing power
  - name: Export power raw
    unique_id: export_power_raw

    address: 13009 # reg 13010
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Load adjustment mode ON/OFF selection raw
    unique_id: load_adjustment_mode_on_off_selection_raw

    address: 13010 # reg 13011
    input_type: holding
    data_type: uint16
    state_class: measurement
    scan_interval: 10

  - name: Daily battery charge from PV
    unique_id: daily_battery_charge_from_pv

    address: 13011 # reg 13012
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery charge from PV
    unique_id: total_battery_charge_from_pv

    address: 13012 # reg 13013
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily direct energy consumption
    unique_id: daily_direct_energy_consumption

    address: 13016 # reg 13017
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total direct energy consumption
    unique_id: total_direct_energy_consumption

    address: 13017 # reg 13018
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Battery voltage
    unique_id: battery_voltage

    address: 13019 # reg 13020
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: V
    device_class: Voltage
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  # note: datasheet states that this value is unsigned, but it is acually signed:
  # https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant/issues/304
  - name: Battery current
    unique_id: battery_current

    address: 13020 # reg 13021
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    state_class: measurement
    device_class: Current
    scale: 0.1
    scan_interval: 10

  # old firmware ( before october 2024): always positive battery power
  # use binary_sensor.battery_charging | discharging to retrieve the direction of the energy flow
  # new firmware: positive if charging and negative if discharging
  # with new firmware installed we could use this raw value directly as signed battery power
  # to support both firmwares we use the template sensor "signed battery power"
  - name: Battery power raw
    unique_id: battery_power_raw

    address: 13021 # reg 13022
    input_type: input
    data_type: int16 #updated to signed int, see issue #406
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  # 0..100%  |  min_soc..max_soc
  - name: Battery level
    unique_id: battery_level

    address: 13022 # reg 13023
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    scale: 0.1
    scan_interval: 60

  # 0..100% calculated internally by the BMS load balancing
  - name: Battery state of health
    unique_id: battery_state_of_health

    address: 13023 # reg 13024
    input_type: input
    data_type: uint16
    precision: 0
    unit_of_measurement: "%"
    state_class: measurement
    scale: 0.1
    scan_interval: 600

  - name: Battery temperature
    unique_id: battery_temperature

    address: 13024 # reg 13025
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: °C
    device_class: temperature
    state_class: measurement
    scale: 0.1
    scan_interval: 60

  - name: Daily battery discharge
    unique_id: daily_battery_discharge

    address: 13025 # reg 13026
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery discharge
    unique_id: total_battery_discharge

    address: 13026 # reg 13027
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Phase A current
    unique_id: phase_a_current

    address: 13030 # reg 13031
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase B current
    unique_id: phase_b_current

    address: 13031 # reg 13032
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Phase C current
    unique_id: phase_c_current

    address: 13032 # reg 13033
    input_type: input
    data_type: int16
    precision: 1
    unit_of_measurement: A
    device_class: current
    state_class: measurement
    scale: 0.1
    scan_interval: 10

  - name: Total active power
    unique_id: total_active_power

    address: 13033 # reg 13034
    input_type: input
    data_type: int32
    swap: word
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Daily imported energy
    unique_id: daily_imported_energy

    address: 13035 # reg 13036
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total imported energy
    unique_id: total_imported_energy

    address: 13036 # reg 13037
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily battery charge
    unique_id: daily_battery_charge

    address: 13039 # reg 13040
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total battery charge
    unique_id: total_battery_charge

    address: 13040 # reg 13041
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600

  - name: Daily exported energy
    unique_id: daily_exported_energy

    address: 13044 # reg 13045
    input_type: input
    data_type: uint16
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total_increasing
    scale: 0.1
    scan_interval: 600

  - name: Total exported energy
    unique_id: total_exported_energy

    address: 13045 # reg 13046
    input_type: input
    data_type: uint32
    swap: word
    precision: 1
    unit_of_measurement: kWh
    device_class: energy
    state_class: total
    scale: 0.1
    scan_interval: 600
    # Enhanced Mode-Sensoren mit map-Funktionalität
  - name: "EMS Mode"
    unique_id: "ems_mode"
    address: 13049
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 10
    map:
      0: "Self-consumption mode (default)"
      1: "Forced mode"
      2: "Backup mode"
      3: "Emergency mode"
    group: "modes"

  - name: Battery forced charge discharge cmd raw
    unique_id: battery_forced_charge_discharge_cmd_raw

    address: 13050 # reg 13051
    input_type: holding
    data_type: uint16
    precision: 0
    state_class: measurement
    scan_interval: 10

  - name: Battery forced charge discharge power
    unique_id: battery_forced_charge_discharge_power

    address: 13051 # reg 13052
    input_type: holding
    data_type: uint16
    precision: 0
    # datasheet says:
    # 0 to 5000 W for SH*K-*
    # 0 to 100 % for SH*.0RT
    # for my SH10RT it is set in Watt, not in %
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scan_interval: 10











  #undocumented sensor (reverse engineered by some guys of photovoltaikforum.com and forum.iobroker.net )
  - name: Reserved SoC for backup
    unique_id: reserved_soc_for_backup

    address: 13099 # reg 13100
    input_type: holding
    data_type: uint16
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    scale: 1
    scan_interval: 10

  - name: Global mpp scan manual raw
    unique_id: global_mpp_scan_manual_raw

    address: 30229 # reg 30230
    input_type: holding
    data_type: uint16
    precision: 0
    state_class: measurement
    scan_interval: 10

  - name: Battery max charge power
    unique_id: battery_max_charge_power

    address: 33046 # reg 33047
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 10
    scan_interval: 10

  - name: Battery max discharge power
    unique_id: battery_max_discharge_power

    address: 33047 # reg 33048
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 10
    scan_interval: 10

  #undocumented sensor (reverse engineered by some guys of photovoltaikforum.com and forum.iobroker.net )
  - name: Battery charging start power
    unique_id: battery_charging_start_power

    address: 33148 # reg 33149
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 10
    scan_interval: 10

  #undocumented sensor (reverse engineered by some guys of photovoltaikforum.com and forum.iobroker.net )
  - name: Battery discharging start power
    unique_id: battery_discharging_start_power

    address: 33149 # reg 33150
    input_type: holding
    data_type: uint16
    precision: 0
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    scale: 10
    scan_interval: 10

# Controls für Schreibzugriff
controls:
  - type: "select"
    name: "EMS Mode Selection"
    address: 13049
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0: "Self-consumption mode (default)"
      1: "Forced mode"
      2: "Backup mode"
      3: "Emergency mode"
    group: "modes"

  - type: "select"
    name: "Load Adjustment Mode"
    address: 13001
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0: "Timing"
      1: "ON/OFF"
      2: "Power optimization"
      3: "Disabled"
    group: "modes"

  - type: "number"
    name: "Export Power Limit"
    address: 13073
    input_type: "holding"
    data_type: "uint16"
    precision: 0
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    scale: 1
    min_value: 0
    max_value: 10000
    step: 100
    scan_interval: 30
    group: "control"

  - type: "number"
    name: "Max SoC"
    unique_id: "sg_max_soc_rw"
    address: 13057
    input_type: "holding"
    data_type: "uint16"
    scale: 0.1
    precision: 1
    unit_of_measurement: "%"
    min_value: 10
    max_value: 100
    step: 1
    scan_interval: 30
    group: "battery_control"

  - type: "number"
    name: "Min SoC"
    unique_id: "sg_min_soc_rw"
    address: 13058
    input_type: "holding"
    data_type: "uint16"
    scale: 0.1
    precision: 1
    unit_of_measurement: "%"
    min_value: 0
    max_value: 90
    step: 1
    scan_interval: 30
    group: "battery_control"

  - type: "select"
    name: "Backup Mode"
    unique_id: "sg_backup_mode_rw"
    address: 13074
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "modes"

  - type: "select"
    name: "Export Power Limit Mode"
    unique_id: "sg_export_power_limit_mode_rw"
    address: 13086
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "Disabled"
      0xAA: "Enabled"
    group: "modes"

  - type: "number"
    name: "Reserved SoC for Backup"
    unique_id: "sg_reserved_soc_backup_rw"
    address: 13099
    input_type: "holding"
    data_type: "uint16"
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    scan_interval: 30
    group: "battery_control"

  - type: "number"
    name: "Battery Max Charge Power"
    unique_id: "sg_battery_max_charge_power_rw"
    address: 33046
    input_type: "holding"
    data_type: "uint16"

  - type: "select"
    name: "Load Adjustment Mode ON/OFF"
    unique_id: "sg_load_adjustment_mode_on_off_rw"
    address: 13010
    input_type: "holding"
    data_type: "uint16"
    scan_interval: 30
    options:
      0x55: "OFF"
      0xAA: "ON"
    group: "modes"
    precision: 0
    unit_of_measurement: "W"
    min_value: 0
    max_value: 10000
    step: 100
    scan_interval: 30
    group: "battery_control"

# Calculated Sensors (based on mkaiser power calculations)
calculated:

  # MPPT Power Calculations
  - name: "MPPT1 Power"
    unique_id: "mppt1_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_mppt1_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_mppt1_current', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt1_voltage') | default(0) | float) * (states('sensor.{PREFIX}_mppt1_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "mppt_power"


  - name: "MPPT2 Power"
    unique_id: "mppt2_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_mppt2_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_mppt2_current', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt2_voltage') | default(0) | float) * (states('sensor.{PREFIX}_mppt2_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "mppt_power"

  # Total Power Calculations
  - name: "Total MPPT Power"
    unique_id: "total_mppt_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_mppt1_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_mppt1_current', 'unavailable')
      and not is_state('sensor.{PREFIX}_mppt2_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_mppt2_current', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_mppt1_voltage') | default(0) | float) * (states('sensor.{PREFIX}_mppt1_current') | default(0) | float) + (states('sensor.{PREFIX}_mppt2_voltage') | default(0) | float) * (states('sensor.{PREFIX}_mppt2_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "total_power"

  # Net Power Calculations (based on mkaiser logic)
  - name: "Net Grid Power"
    unique_id: "net_grid_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') }}
    state: "{{ states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "grid_power"

  - name: "Grid Import Power"
    unique_id: "grid_import_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float > 0 %}
        {{ states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "grid_power"

  - name: "Grid Export Power"
    unique_id: "grid_export_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float < 0 %}
        {{ (states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float) | abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "grid_power"

  

  # Load Power Calculations
  - name: "Total Load Power"
    unique_id: "total_load_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_load_power', 'unavailable') }}
    state: "{{ states('sensor.{PREFIX}_load_power') | default(0) | float }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "load_power"

  # System Efficiency Calculations
  - name: "Solar to Grid Efficiency"
    unique_id: "solar_to_grid_efficiency"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable') 
      and not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') 
      }}
    state: "{% set pv = states('sensor.{PREFIX}_total_dc_power') | default(0) | float %}{% set grid = states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float %}{% if pv > 0 and grid < 0 %}{{ (grid | abs / pv * 100) | round(1) }}{% else %}0{% endif %}"
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    group: "efficiency"

  - name: "Battery to Load Efficiency"
    unique_id: "battery_to_load_efficiency"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_total_pv_generation', 'unavailable') 
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable') 
      }}
    state: "{% set pv = states('sensor.{PREFIX}_total_pv_generation') | default(0) | float %}{% set load = states('sensor.{PREFIX}_load_power') | default(0) | float %}{% if pv > 0 %}{{ (load / pv * 100) | round(1) }}{% else %}0{% endif %}"
    unit_of_measurement: "%"
    device_class: "power_factor"
    state_class: "measurement"
    group: "efficiency"

  # Power Balance Calculations
  - name: "Power Balance"
    unique_id: "power_balance"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_total_dc_power', 'unavailable') 
      and not is_state('sensor.{PREFIX}_battery_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
      and not is_state('sensor.{PREFIX}_load_power', 'unavailable')
      }}
    state: "{{ (states('sensor.{PREFIX}_total_dc_power') | default(0) | float) + (states('sensor.{PREFIX}_battery_power_raw') | default(0) | float) + (states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float) - (states('sensor.{PREFIX}_load_power') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "power_balance"

  # Phase Power Calculations
  - name: "Total Phase Power"
    unique_id: "total_phase_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_meter_phase_a_active_power_raw', 'unavailable') 
      and not is_state('sensor.{PREFIX}_meter_phase_b_active_power_raw', 'unavailable') 
      and not is_state('sensor.{PREFIX}_meter_phase_c_active_power_raw', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_meter_phase_a_active_power_raw') | default(0) | float) + (states('sensor.{PREFIX}_meter_phase_b_active_power_raw') | default(0) | float) + (states('sensor.{PREFIX}_meter_phase_c_active_power_raw') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "phase_power"

  # Individual Phase Power Calculations (based on mkaiser)
  - name: "Phase A Power"
    unique_id: "phase_a_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_phase_a_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_phase_a_current', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_a_voltage') | default(0) | float) * (states('sensor.{PREFIX}_phase_a_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "phase_power"

  - name: "Phase B Power"
    unique_id: "phase_b_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_phase_b_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_phase_b_current', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_b_voltage') | default(0) | float) * (states('sensor.{PREFIX}_phase_b_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "phase_power"

  - name: "Phase C Power"
    unique_id: "phase_c_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_phase_c_voltage', 'unavailable') 
      and not is_state('sensor.{PREFIX}_phase_c_current', 'unavailable') 
      }}
    state: "{{ (states('sensor.{PREFIX}_phase_c_voltage') | default(0) | float) * (states('sensor.{PREFIX}_phase_c_current') | default(0) | float) }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "phase_power"

  # Enhanced Battery Power Calculations (based on mkaiser)
  - name: "Signed Battery Power"
    unique_id: "signed_battery_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_battery_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_battery_power_raw') | default(0) | float > 0 %}
        {{ (states('sensor.{PREFIX}_battery_power_raw') | default(0) | float) | abs }}
      {% elif states('sensor.{PREFIX}_battery_power_raw') | default(0) | float < 0 %}
        {{ (states('sensor.{PREFIX}_battery_power_raw') | default(0) | float) | abs * -1 }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "battery_power"

  # Battery Power Calculations
  - name: "Battery Charging Power"
    unique_id: "battery_charging_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_battery_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_battery_power_raw') | default(0) | float > 0 %}
        {{ (states('sensor.{PREFIX}_battery_power_raw') | default(0) | float) | abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "battery_charging"

  - name: "Battery Discharging Power"
    unique_id: "battery_discharging_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_battery_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_battery_power_raw') | default(0) | float < 0 %}
        {{ (states('sensor.{PREFIX}_battery_power_raw') | default(0) | float) | abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "battery_discharging"

  # Enhanced Grid Power Calculations (based on mkaiser)
  - name: "Import Power"
    unique_id: "import_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float > 0 %}
        {{ states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "grid_import"

  - name: "Export Power"
    unique_id: "export_power"
    type: "sensor"
    availability: >-
      {{ not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable') }}
    state: >-
      {% if states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float < 0 %}
        {{ (states('sensor.{PREFIX}_meter_active_power_raw') | default(0) | float) | abs }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "grid_export"

  # calculated sensor in case the meter is not available (grid is off) and returns 0x7FFFFF
  - name: "Meter Active Power"
    unique_id: "meter_active_power"
    type: "sensor"
    availability: >-
          {{ 
          not is_state('sensor.{PREFIX}_meter_active_power_raw', 'unavailable')
          and states('sensor.{PREFIX}_meter_active_power_raw')|int != 0x7FFFFFFF
          }}
    state: "{{ states('sensor.{PREFIX}_meter_active_power_raw') }}"
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "meter_power"

  - name: "Meter Phase A Active Power"
    unique_id: "meter_phase_a_active_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_meter_phase_a_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_a_active_power_raw')|int != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_a_power = states('sensor.{PREFIX}_meter_phase_a_active_power_raw') | default(0) | float %}
      {% if phase_a_power != 0x7FFFFFFF and phase_a_power != 2147483647 %}
        {{ phase_a_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "meter_power"

  - name: "Meter Phase B Active Power"
    unique_id: "meter_phase_b_active_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_meter_phase_b_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_b_active_power_raw')|int != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_b_power = states('sensor.{PREFIX}_meter_phase_b_active_power_raw') | default(0) | float %}
      {% if phase_b_power != 0x7FFFFFFF and phase_b_power != 2147483647 %}
        {{ phase_b_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "meter_power"

  - name: "Meter Phase C Active Power"
    unique_id: "meter_phase_c_active_power"
    type: "sensor"
    availability: >-
      {{ 
      not is_state('sensor.{PREFIX}_meter_phase_c_active_power_raw', 'unavailable')
      and states('sensor.{PREFIX}_meter_phase_c_active_power_raw')|int != 0x7FFFFFFF
      }}
    state: >-
      {% set phase_c_power = states('sensor.{PREFIX}_meter_phase_c_active_power_raw') | default(0) | float %}
      {% if phase_c_power != 0x7FFFFFFF and phase_c_power != 2147483647 %}
        {{ phase_c_power }}
      {% else %}
        0
      {% endif %}
    unit_of_measurement: "W"
    device_class: "power"
    state_class: "measurement"
    group: "meter_power"
